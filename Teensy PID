//to stop integral windup, 0.2 = 0.00 deg 

#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <QMC5883LCompass.h>
#include <PID_v1_bc.h>

// Sensor Objects
Adafruit_MPU6050 mpu;
QMC5883LCompass compass;

// PID Variables
double setR = 0, inputR, outR; // Roll
double setP = 0, inputP, outP; // Pitch
double setY = 0, inputY, outY; // Yaw

// TUNING: Start with Ki = 0 to verify the "creep" is gone, then add tiny amounts (e.g., 0.01)
double Kp = 2.0, Ki = 0.0, Kd = 1.0; 

PID pidR(&inputR, &outR, &setR, Kp, Ki, Kd, DIRECT);
PID pidP(&inputP, &outP, &setP, Kp, Ki, Kd, DIRECT);
PID pidY(&inputY, &outY, &setY, Kp, Ki, Kd, DIRECT);

// Filter Variables
float roll = 0, pitch = 0, yaw = 0;
unsigned long lastTime;

void setup() {
  Serial.begin(115200);
  Wire.begin();

  if (!mpu.begin()) { while (1); }
  mpu.setI2CBypass(true); 
  compass.init();

  // Initialize PID Settings
  pidR.SetMode(AUTOMATIC);
  pidP.SetMode(AUTOMATIC);
  pidY.SetMode(AUTOMATIC);

  // LIMITS: Essential for Anti-Windup in the _bc library
  pidR.SetOutputLimits(-255, 255);
  pidP.SetOutputLimits(-255, 255);
  pidY.SetOutputLimits(-255, 255);

  lastTime = millis();
}

void loop() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  compass.read();

  float dt = (millis() - lastTime) / 1000.0;
  lastTime = millis();

  // --- 1. SENSOR FUSION (Angle Calculation) ---
  float accPitch = atan2(a.acceleration.y, a.acceleration.z) * 180 / PI;
  float accRoll  = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180 / PI;
  float magHeading = atan2(compass.getY(), compass.getX()) * 180 / PI;

  // Complementary Filter
  pitch = 0.98 * (pitch + g.gyro.x * 180/PI * dt) + 0.02 * accPitch;
  roll  = 0.98 * (roll + g.gyro.y * 180/PI * dt) + 0.02 * accRoll;
  yaw   = 0.95 * (yaw + g.gyro.z * 180/PI * dt) + 0.05 * magHeading;

  // --- 2. THE ANTI-CREEP FIX (Deadband) ---
  // If error is less than 0.5 degrees, we force input to match setpoint
  // This stops the 'I' term from accumulating tiny errors while sitting still.
  inputR = (abs(roll - setR) < 0.5) ? setR : roll;
  inputP = (abs(pitch - setP) < 0.5) ? setP : pitch;
  inputY = (abs(yaw - setY) < 0.5) ? setY : yaw;

  // --- 3. COMPUTE ---
  pidR.Compute();
  pidP.Compute();
  pidY.Compute();

  // --- 4. OUTPUT / DEBUG ---
  Serial.print("P:"); Serial.print(outP); 
  Serial.print(" R:"); Serial.print(outR); 
  Serial.print(" Y:"); Serial.println(outY);

  delay(10); 
}
