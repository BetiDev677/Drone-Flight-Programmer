//to stop integral windup, 0.02 = 0.00 deg for PID

#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <QMC5883LCompass.h>
#include <PID_v1_bc.h>
#include <Servo.h>

// Sensor Objects
Adafruit_MPU6050 mpu;
QMC5883LCompass compass;
Servo m1, m2, m3, m4;

// PID Variables
double setR = 0, inputR, outR; // Roll
double setP = 0, inputP, outP; // Pitch
double setY = 0, inputY, outY; // Yaw

// TUNING: Start with Ki = 0 to verify the "creep" is gone, then add tiny amounts (e.g., 0.01)
double Kp = 2.0, Ki = 0.0, Kd = 1.0; 

PID pidR(&inputR, &outR, &setR, Kp, Ki, Kd, DIRECT);
PID pidP(&inputP, &outP, &setP, Kp, Ki, Kd, DIRECT);
PID pidY(&inputY, &outY, &setY, Kp, Ki, Kd, DIRECT);

// Filter Variables
float roll = 0, pitch = 0, yaw = 0;
unsigned long lastTime;
int throttle = 1100; //Idle, set 1000 to keep motor off

void setup() {
  Serial.begin(115200);
  Wire.begin();
  m1.attach(2, 1000, 2000);
  m1.attach(3, 1000, 2000);
  m1.attach(4, 1000, 2000);
  m1.attach(5, 1000, 2000);
  m1.writeMicroseconds(1000); 
  m2.writeMicroseconds(1000); 
  m3.writeMicroseconds(1000); 
  m4.writeMicroseconds(1000); 
  delay(20);
  if (!mpu.begin()) { Serial.println("MPU failed to connect"); }
  mpu.setI2CBypass(true); 
  compass.init();

  // Initialize PID Settings
  pidR.SetMode(AUTOMATIC);
  pidP.SetMode(AUTOMATIC);
  pidY.SetMode(AUTOMATIC);

  // Limits for Anti-Windup in the _bc library
  pidR.SetOutputLimits(-255, 255);
  pidP.SetOutputLimits(-255, 255);
  pidY.SetOutputLimits(-255, 255);

  lastTime = millis();
}

void loop() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  compass.read();

  float dt = (millis() - lastTime) / 1000.0;
  lastTime = millis();

//fusion
  float accPitch = atan2(a.acceleration.y, a.acceleration.z) * 180 / PI;
  float accRoll  = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180 / PI;
  float magHeading = atan2(compass.getY(), compass.getX()) * 180 / PI;

  // Complementary Filter
  pitch = 0.98 * (pitch + g.gyro.x * 180/PI * dt) + 0.02 * accPitch;
  roll  = 0.98 * (roll + g.gyro.y * 180/PI * dt) + 0.02 * accRoll;
  yaw   = 0.95 * (yaw + g.gyro.z * 180/PI * dt) + 0.05 * magHeading;


  // If error is less than 0.5 degrees, we force input to match setpoint
  // This stops the 'I' term from accumulating tiny errors while sitting still.
  inputR = (abs(roll - setR) < 0.5) ? setR : roll;
  inputP = (abs(pitch - setP) < 0.5) ? setP : pitch;
  inputY = (abs(yaw - setY) < 0.5) ? setY : yaw;

  pidR.Compute();
  pidP.Compute();
  pidY.Compute();

  int s1 = throttle - outP + outR + outY; // Front Right (CCW)
  int s2 = throttle + outP + outR - outY; // Back Right (CW)
  int s3 = throttle + outP - outR + outY; // Back Left (CCW)
  int s4 = throttle - outP - outR - outY; // Front Left (CW)
  Serial.print(s1);
  Serial.print(s2);
  Serial.print(s3);
  Serial.print(s4);
  m1.writeMicroseconds(constrain(s1, 1000, 2000));
  m2.writeMicroseconds(constrain(s2, 1000, 2000));
  m3.writeMicroseconds(constrain(s3, 1000, 2000));
  m4.writeMicroseconds(constrain(s4, 1000, 2000));

  delay(10); 
}
